Introduction
------------

This project uses a kind of dependency system to make sure that the .h files
and their contents are included in the right order when compiling. It makes heavy
use of the preprocessor. I think it's best explained with an example, so here
goes with an example for an imaginary foo.h:

Example: foo.h
--------------

// Here comes the first section, the so-called pre section. It only contains macros
// and prototypes of structs and classes. Thus it has no dependencies, but other
// files might depend on this stuff being defined. Oh, and it includes the .h files
// that the main section of foo.h depends on.
#ifndef __FOO_H_PRE__

	#define __FOO_H_PRE__ // make sure the pre section isn't included again

	#ifdef DEBUG_DEP
		#warning "foo.h-pre" // output a warning when the pre section of this file
		                     // is included; this is useful for debug purposes
	#endif

	namespace Foo
	{
		struct Foo_struct;
		class Foo_class;
	}

	#define __FOO_H_PRE_END__ // define __FOO_H_PRE_END__ to signal that the pre
	                          // section of foo.h is completely included

	#include "bar.h"
	#include "baz.h"

#endif

// Here comes the main section of foo.h. It contains everything that might depend on
// other stuff being included.
#ifdef __BAR_H_END__    // depend on the full bar.h being included before including the main section

	#ifdef __BAZ_H_PRE_END__  // depend on that the pre section is already included

		#ifndef __FOO_H__

			#define __FOO_H__  // make sure the main section isn't included again

			#ifdef DEBUG_DEP
				#warning "foo.h" // emit debug info
			#endif

			namespace Foo
			{
				...    // actually define the classes, structs and their contents and everything else you might have
			}

			#ifdef DEBUG_DEP
				#warning "foo.h-end" // emit debug info
			#endif

			#define __FOO_H_END__  // signal that the main section of foo.h has been fully included

		#endif

	#endif

#endif

When to include the pre section and when to not
-----------------------------------------------

When you need a pointer to a class or a struct defined in another .h file, you
only need to depend on the pre section in the .h file. However, if you need to
create 'static' non-pointer instances of a class or a struct, you need to
depend on the main section/full file.

Common Actions
--------------

A: The .cpp file needs a .h file, but the .h itself doesn't need it.
S: Include the .h file in .cpp source file.

A: The main section of the .h needs pointers of structs/classes from another .h.
S: Include the latter .h at the end of the pre section of the former .h, and
   depend on the pre section of the .h file.

A: The main section of the .h needs access to structs/classes (not pointers) from 
   another .h.
S: Include the latter .h at the end of the pre section of the former .h, and
   depend on the main section of the .h file.

Circular dependencies
---------------------

Accidently creating circular dependencies is easy. Even I did it ;)
Anyway, what happens when you happen to create one, is that neither of the files
that are affected by it will be included. You will thus very likely get errors
from your .cpp file telling you that some symbols in any of the .h files
aren't defined. The solution is to find out which files are involved in the
circular dependency and break the circular dependency at any of the steps.
Usually this involves finding the one of the dependencies that doesn't need to
be on the main section, and make it depend on the pre section instead.

Current dependencies as of 061204
---------------------------------

dimension: aibase, vector3d, vrmlparser_pre
aipathfinding: dimension, unit_pre
aibase: unit_pre
vector3d: terrain_pre
utilities: window
unit: aipathfinding_pre, aibase_pre, dimension, vector3d, game, terrain
terrain: vector3d, unit_pre
window: utilities_pre
audio: vector3d
vrmlparser: unit_pre
game: terrain
lua: none

Possible order they might be included in:
aibase_pre
utilities_pre
window
aipathfinding_pre
terrain_pre
unit_pre
vector3d
terrain
vrmlparser_end
aibase
dimension
game
unit
aipathfinding
utilities
audio
lua
